<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tykkipeli</title>
    <style>
        canvas {
            position: absolute;
            left: 0;
            top: 0;
            border: 1px solid black;
        }
        
    </style>
</head>
<body>
    <h1 id="ruuti">Säädä ruutimäärä vasemmalle tai oikealle nuolinäppäimellä</h1>
    <h1 id='kulma'>Säädä kulmaa ylös-tai alas nuolinäppäimellä</h1>
    <h1 id='kapum'>Laukaise painamalla Enter</h1>
    <!-- Ensimmäinen canvas nurmikolle -->
 
    <canvas id="terrainCanvas" ></canvas>
    <!-- Toinen canvas tankkien ja ammusten piirtämiseen -->
    <canvas id="gameCanvas" ></canvas>
    <script>
        // Haetaan molemmat canvas-elementit ja niiden piirtoyhteydet
const kenttaCanvas = document.getElementById('terrainCanvas');
const kenttaCtx = kenttaCanvas.getContext('2d');
const ammusCanvas = document.getElementById('gameCanvas');
const ammusCtx = ammusCanvas.getContext('2d');

function resizeCanvas() { //cancaksen koko on sama kuin ikkunan koko
    ammusCanvas.width = window.innerWidth;
    ammusCanvas.height = window.innerHeight;
    kenttaCanvas.width = window.innerWidth;
    kenttaCanvas.height = window.innerHeight;
}

// jos ikkunan koko muuttuu päivittyyy myös canvas uutta kokoa vastaavaksi
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// fysiikka muuttujia
const painovoima = 0.7;
const kitka = 0.99;

// maaston koordinaattipisteet
const terrainPoints = [];

//kulma näyttö
const kulmanaytto = document.getElementById('kulma');
//laukaisunäyytö
const laukaisunautto = document.getElementById('kapum');

const voimanaytto = document.getElementById('ruuti');






// Piirretään nurmikko terrain-canvasille ja tallennetaan maaston pisteet
function drawTerrain() {
    const kenttaLeveys = kenttaCanvas.width;
    const kenttaKorkeus = kenttaCanvas.height;

      // koordinaatit
      const pisteet = [
        { x: 0, y: kenttaKorkeus - 50 }, // aloituspiste
        { x: kenttaLeveys * 0.10, y: kenttaKorkeus - 50},//alussa tasainen tila tykille, onko riittävä
        { x: kenttaLeveys * 0.15, y: kenttaKorkeus - Math.random()*400 }, //random korkeudet tässä välissä
        { x: kenttaLeveys * 0.20, y: kenttaKorkeus - Math.random()*400 },// säätää voi vuorenhuippuja miltä tuntuu
        { x: kenttaLeveys * 0.30, y: kenttaKorkeus - Math.random()*500 },
        { x: kenttaLeveys * 0.55, y: kenttaKorkeus - Math.random()*500},
        { x: kenttaLeveys * 0.65, y: kenttaKorkeus - Math.random()*400 },
        { x: kenttaLeveys * 0.75, y: kenttaKorkeus - Math.random()*400 },
        { x: kenttaLeveys * 0.90, y: kenttaKorkeus - 50 }, //lopussa myös tykille tila
        { x: kenttaLeveys, y: kenttaKorkeus - 50 } // Lopetuspiste
    ];

    kenttaCtx.beginPath();
    kenttaCtx.moveTo(pisteet[0].x, pisteet[0].y); // aloituspiste

    for (let i = 1; i < pisteet.length; i++) {
        kenttaCtx.lineTo(pisteet[i].x, pisteet[i].y);
        terrainPoints.push(pisteet[i]); // maaston pisteet tallennetaan
    }

    // Piirretään maaston alareuna
    kenttaCtx.lineTo(kenttaLeveys, kenttaKorkeus);
    kenttaCtx.lineTo(0, kenttaKorkeus);
    kenttaCtx.closePath();

    // Täytetään maasto vihreällä värillä
    kenttaCtx.fillStyle = 'green';
    kenttaCtx.fill();

    // Rekvisiitta - aurinko
    kenttaCtx.beginPath();
    kenttaCtx.arc(Math.random() * kenttaLeveys, 100, 40, 0, 2 * Math.PI);
    kenttaCtx.fillStyle = "yellow";
    kenttaCtx.fill();
    kenttaCtx.stroke();


    //pilvet nyt pois koska tulevat tekstin päälle?
    //drawCloud(Math.random()*(kenttaLeveys-40), 100, 40); //piirrä pilvi parametrien mukaan
    //drawCloud(Math.random()*(kenttaLeveys-60), 100, 60); //toinenki


}


// Funktio, joka palauttaa maaston korkeuden tietyssä x-koordinaatissa
function getTerrainHeightAt(x) {
    for (let i = 0; i < terrainPoints.length - 1; i++) {
        if (x >= terrainPoints[i].x && x <= terrainPoints[i + 1].x) {
            // Interpoloi korkeus pisteiden välillä
            const dx = terrainPoints[i + 1].x - terrainPoints[i].x;
            const dy = terrainPoints[i + 1].y - terrainPoints[i].y;
            const ratio = (x - terrainPoints[i].x) / dx;
            return terrainPoints[i].y + ratio * dy;
        }
    }
    return ammusCanvas.height; // Oletuskorkeus, jos x-koordinaatti on kentän ulkopuolella
}

// Tykki-luokka
class Tykki {
    constructor(x, y, vari) {
        this.x = x;
        this.y = y;
        this.vari = vari;//väri, tarpeeton myöhemmin?
        this.kulma = 45;
        this.ruuti = 20;
    }
    //tykin piirto, lähinnä esimerkiksi tämähän korvataan kuvalla
    draw() {
        ammusCtx.fillStyle = this.vari;
        ammusCtx.fillRect(this.x - 15, this.y - 10, 30, 20); // tykin runko
        ammusCtx.beginPath();
        ammusCtx.moveTo(this.x, this.y);
        const tykin_putkiX = this.x + Math.cos(this.kulma * Math.PI / 180) * 30;
        const tykin_putkiY = this.y - Math.sin(this.kulma * Math.PI / 180) * 30;
        ammusCtx.lineTo(tykin_putkiX, tykin_putkiY);
        ammusCtx.stroke();
    }
    //uusi kulma säätöä varten
    setAngle(uusiKulma) {
        this.kulma = uusiKulma;
    }
    //uusi ruuti
    setPower(uusiRuuti){
        this.ruuti = uusiRuuti;
    }










}

// Ammus-luokka
class Ammus {
    constructor(x, y, kulma, ruuti) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(kulma * Math.PI / 180) * ruuti;
        this.vy = -Math.sin(kulma * Math.PI / 180) * ruuti;
    }

    update() {
        this.vy += painovoima;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= kitka;
        this.vy *= kitka;
        this.checkCollision();
    }

    draw() {
        ammusCtx.beginPath();
        ammusCtx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        ammusCtx.fillStyle = 'black';
        ammusCtx.fill();
    }
    
    //  osuuko ammus maahan ja tehdään kolo, jos osuu
    checkCollision() {
        const terrainHeight = getTerrainHeightAt(this.x); // Haetaan maaston korkeus tässä x-koordinaatissa
        if (this.y > terrainHeight) { // Tarkistetaan osuma maastoon
            const craterRadius = 25; // Kolon säde
            kenttaCtx.globalCompositeOperation = 'destination-out';
            kenttaCtx.beginPath();
            kenttaCtx.arc(this.x, terrainHeight, craterRadius, 0, Math.PI * 2);
            kenttaCtx.fill();
            kenttaCtx.globalCompositeOperation = 'source-over';

            return true;
        }
        return false;
    }
}

let ammukset = [];

const tykki = new Tykki(100, ammusCanvas.height - 60, 'crimson'); //yksi testitykki



document.addEventListener('keydown', function(event) { 
    if (event.key === 'ArrowUp') { 
        tykki.setAngle(tykki.kulma + 1); // Nostaa kulmaa 1 astetta
        kulmanaytto.textContent = `Kulma on ${tykki.kulma} astetta`
    } else if (event.key === 'ArrowDown') {
        tykki.setAngle(tykki.kulma - 1); // Laskee kulmaa 1 astett
        kulmanaytto.textContent = `Kulma on ${tykki.kulma} astetta`
    }
});


document.addEventListener('keydown',function (event)  {
    if(event.key === 'Enter'){

        const ammus = new Ammus(tykki.x, tykki.y - 10, tykki.kulma, tykki.ruuti);
        ammukset.push(ammus);
        laukaisunautto.textContent = 'PUM!'
        setTimeout(function(){
            laukaisunautto.textContent = 'Laukaise painamalla Enter';
        },1000);
    }
    
});


document.addEventListener('keydown', function(event) { 
    if (event.key === 'ArrowLeft') { 
        tykki.setPower(tykki.ruuti + 1); // voima+ 1 astetta
        voimanaytto.textContent = `Voima on ${tykki.ruuti}`
    } else if (event.key === 'ArrowRight') {
        tykki.setPower(tykki.ruuti - 1); // voima + 1 astett
        voimanaytto.textContent = `Voima on ${tykki.ruuti}`
    }
});






function gameLoop() {
    ammusCtx.clearRect(0, 0, ammusCanvas.width, ammusCanvas.height);

    //tykkien piirto
    tykki.draw();
    
    // Päivitetään ja piirretään ammukset
    ammukset.forEach((ammus, index) => {
        ammus.update();
        ammus.draw();

        // Tarkistetaan osumat ja poistetaan ammus, jos osuu
        if (ammus.checkCollision()) {
            ammukset.splice(index, 1);
        }
    });

    requestAnimationFrame(gameLoop);
}
//piirretään pilvi
function drawCloud(x, y, koko) {
    const pilvenvarit = ['white','#8e8e94','#67676b'];

    kenttaCtx.fillStyle = pilvenvarit[Math.floor(Math.random()*pilvenvarit.length)]; // pilven väri, tätä ei oo pakko laittaa kunhan kokeilin miltä näyttää
    kenttaCtx.beginPath();
    
    //pilvet
    kenttaCtx.arc(x, y, koko, Math.PI * 0.5, Math.PI * 1.6);
    kenttaCtx.arc(x + koko, y - koko, koko, Math.PI * 1, Math.PI * 2);
    kenttaCtx.arc(x + koko * 2, y, koko, Math.PI * 1.5, Math.PI * 0.5);
    

    kenttaCtx.closePath();
    kenttaCtx.fill(); 




    
}



// Piirretään maasto ja aloitetaan pelisilmukka
drawTerrain();
gameLoop();




    </script>



   
    
  
</body>
</html>
